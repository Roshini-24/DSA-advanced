 #Function to compare two strings and updating res
    #which stores the string with larger number.
    def match(self, num, res):
        
        for i in range(len(num)):
            if res[i] > num[i]:
                return
            
            #if num[i] is greater, we update res as num or store
            #the larger value in res.
            if res[i] < num[i]:
                
                for i in range(len(num)):
                    res[i] = num[i]
                return

    #Function to set highest possible digits at given index.
    def setDigit(self, num, index, res, k):
        
        # base case
        if k==0 or index==len(num)-1:
            self.match(num,res)
            return
        
        maxDigit = 0
        
        #finding maximum digit for placing at given index.
        for i in range(index, len(num) ):
            maxDigit = max( maxDigit, num[i] )
        
        # swapping isn't needed in this case.
        if num[index] == maxDigit:
            self.setDigit( num, index+1, res, k )
            return
        
        for i in range(index+1, len(num)):
            
            # if max digit is found at current index.
            if num[i] == maxDigit:
                
                #swapping to get the maximum digit at required index.
                num[index] , num[i] = num[i] , num[index]
                
                #calling recursive function to set the next digit
                self.setDigit(num, index+1, res, k-1);
                
                # backtracking
                num[index] , num[i] = num[i] , num[index]
                
                
    #Function to find the largest number after k swaps.
    def findMaximumNum(self, s,k):
        
        num = [ int(x) for x in s ]
        res = [ int(x) for x in s ]
        
        self.setDigit(num, 0, res, k)
        #returning the result.
        return ''.join( str(x) for x in res )




#Function to find out the number of ways we can place a black and a white
#Knight on this chessboard such that they cannot attack each other.
def numOfWays(m,n):
    
    #specifying the directions to check in i.e 8 directions.
    x_off = [-2,-2,-1, 1, 2, 2, 1, -1]
    y_off = [-1, 1, 2, 2, 1,-1, -2, -2]
    MOD = 1000000007

    #variable to maintain number of positions which are not feasible.
    ret = 0

    #iterating for complete matrix.
    for i in range(m):
        for j in range(n):
            for k in range(8):
                
                x = i + x_off[k]
                y = j + y_off[k]
                
                #checking if the attack position is within bounds.
                if x>=0 and x<m and y>=0 and y<n :
                    #if in bounds then it is not feasible so we increment.
                    ret+=1 
    
    #total possible combinations of 2 knights.
    total = ((m*n)*(m*n-1))%MOD 
    #returning total feasible combinations.
    return (total +MOD - ret)%MOD 





def isSafe(x,y,n,mat):
    #Check if the current cell is out of bounds or is blocked (contains a 0)
    if (x<0 or y<0 or x>n-1 or y>n-1 or mat[x][y]==0):
        return False
    return True

class Solution:
    def ShortestDistance(self, mat):
        #Create a 2D array to store the shortest distance matrix
        self.res = [[0 for i in range(len(mat))] for i in range(len(mat))]
        n = len(mat)
        
        #If the starting cell is blocked, return -1
        if mat[0][0]==0 and n!=1:
            return [[-1]]
        
        def path(m,i,j,pathh):
            #If we have reached the destination, mark it in the shortest distance matrix and return True
            if (i==n-1 and j==n-1):
                self.res[i][j]=1
                return True
                
            #Check if the current cell is safe to move to
            if isSafe(i,j,n,mat):
                #Mark the current cell as visited in the shortest distance matrix
                self.res[i][j]=1

                #Try all possible moves from the current cell
                for x in range(1,m[i][j]+1):
                    #Move right
                    if path(m,i,j+x,pathh):
                        return True

                    #Move down
                    if path(m,i+x,j,pathh):
                        return True

                #If none of the moves leads to the destination, mark the current cell as unvisited and return False
                self.res[i][j]=0
                return False
            return False
            
        #Call the path() function to find the shortest distance matrix
        path(mat,0,0,"")
        return self.res





class Solution:
    def sumUtil(self,a,n,s,result,temp,index):
        
        #returning if conditions are out of bound. 
        if(index>=n or s<0): 
            return
    
        #pushing the combination in result if the sum becomes equal to 0.
        if(s==0): 
            result.append(temp[:])
            return
        
        #pushing to temp for possible answer.
        temp.append(a[index])
        
        #calling function recursively for further inclusions.
        self.sumUtil(a,n,s-temp[-1],result,temp,index) 
        
        #backtracking to remove already present number in combination
        #and provide space for further additions and possible answers.
        temp.pop() 
        
        #calling function recursively to move to next index as all possible
        #combination for current index have been done.
        self.sumUtil(a,n,s,result,temp,index+1) 
    
    
    #Function to return a list of indexes denoting the required 
    #combinations whose sum is equal to given number.
    def combinationalSum(self,a,s):
        
        #putting in set and removing duplicates from array a.
        a=set(a) 
        a=list(a)
    
        #sorting a to maintain order.
        a.sort() 
        result = []
        self.sumUtil(a,len(a),s,result,[],0) 
        
        #returning the result.
        return result 

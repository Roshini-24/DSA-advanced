 #Function to compare two strings and updating res
    #which stores the string with larger number.
    def match(self, num, res):
        
        for i in range(len(num)):
            if res[i] > num[i]:
                return
            
            #if num[i] is greater, we update res as num or store
            #the larger value in res.
            if res[i] < num[i]:
                
                for i in range(len(num)):
                    res[i] = num[i]
                return

    #Function to set highest possible digits at given index.
    def setDigit(self, num, index, res, k):
        
        # base case
        if k==0 or index==len(num)-1:
            self.match(num,res)
            return
        
        maxDigit = 0
        
        #finding maximum digit for placing at given index.
        for i in range(index, len(num) ):
            maxDigit = max( maxDigit, num[i] )
        
        # swapping isn't needed in this case.
        if num[index] == maxDigit:
            self.setDigit( num, index+1, res, k )
            return
        
        for i in range(index+1, len(num)):
            
            # if max digit is found at current index.
            if num[i] == maxDigit:
                
                #swapping to get the maximum digit at required index.
                num[index] , num[i] = num[i] , num[index]
                
                #calling recursive function to set the next digit
                self.setDigit(num, index+1, res, k-1);
                
                # backtracking
                num[index] , num[i] = num[i] , num[index]
                
                
    #Function to find the largest number after k swaps.
    def findMaximumNum(self, s,k):
        
        num = [ int(x) for x in s ]
        res = [ int(x) for x in s ]
        
        self.setDigit(num, 0, res, k)
        #returning the result.
        return ''.join( str(x) for x in res )




#Function to find out the number of ways we can place a black and a white
#Knight on this chessboard such that they cannot attack each other.
def numOfWays(m,n):
    
    #specifying the directions to check in i.e 8 directions.
    x_off = [-2,-2,-1, 1, 2, 2, 1, -1]
    y_off = [-1, 1, 2, 2, 1,-1, -2, -2]
    MOD = 1000000007

    #variable to maintain number of positions which are not feasible.
    ret = 0

    #iterating for complete matrix.
    for i in range(m):
        for j in range(n):
            for k in range(8):
                
                x = i + x_off[k]
                y = j + y_off[k]
                
                #checking if the attack position is within bounds.
                if x>=0 and x<m and y>=0 and y<n :
                    #if in bounds then it is not feasible so we increment.
                    ret+=1 
    
    #total possible combinations of 2 knights.
    total = ((m*n)*(m*n-1))%MOD 
    #returning total feasible combinations.
    return (total +MOD - ret)%MOD 

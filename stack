class TwoStacks:
    def __init__(self, n=100):
        # Size of the array
        self.size = n

        # Array to store elements
        self.arr = [0] * n

        # Top index of stack 1
        self.top1 = -1

        # Top index of stack 2
        self.top2 = n

    # Function to push an integer into stack 1
    def push1(self, x):
        # If there is space between the top of both stacks,
        # we push the element at top1+1.
        if self.top1 < self.top2 - 1:
            self.top1 += 1
            self.arr[self.top1] = x

    # Function to push an integer into stack 2
    def push2(self, x):
        # If there is space between the top of both stacks,
        # we push the element at top2-1.
        if self.top1 < self.top2 - 1:
            self.top2 -= 1
            self.arr[self.top2] = x

    # Function to remove an element from top of stack 1
    def pop1(self):
        # If top1 == -1, stack1 is empty so we return -1,
        # else we return the top element of stack1.
        if self.top1 >= 0:
            x = self.arr[self.top1]
            self.top1 -= 1
            return x
        else:
            return -1

    # Function to remove an element from top of stack 2
    def pop2(self):
        # If top2 == size of array, stack2 is empty so we return -1,
        # else we return the top element of stack2.
        if self.top2 < self.size:
            x = self.arr[self.top2]
            self.top2 += 1
            return x
        else:
            return -1



class Solution:
    def stackMiddle(self,n,stack):
        if n==1:
            return stack[n-1]
        mid = n//2
        if n%2==0:
            return stack[mid-1]
        else:
            return stack[mid]



class Solution:
    def reverseArray(self,n,arr):
        if n==1:
            return arr
        
        st=[]
        for i in range(n):
            st.append(arr[i])
        
        for i in range(n):
            arr[i] = st.pop()



 #Function to calculate the span of stockâ€™s price for all n days.
    def calculateSpan(self,a,n):
        
    # Create a stack and push index of first element to it
        st = []
        st.append(0)
        S=[0]*n
    
        # Span value of first element is always 1
        S[0] = 1
    
        # Calculate span values for rest of the elements
        for i in range(1, n):
            
            # Pop elements from stack while stack is not
            # empty and top of stack is smaller than price[i]
            while( len(st) > 0 and a[st[-1]] <= a[i]):
                st.pop()
    
            # If stack becomes empty, then price[i] is greater
            # than all elements on left of it, i.e. price[0],
            # price[1], ..price[i-1]. Else the price[i] is
            # greater than elements after top of stack
            S[i] = i + 1 if len(st) <= 0 else (i - st[-1])
    
            # Push this element to stack
            st.append(i)
        return S


#Function to push all the elements into the stack.
def _push(a,n):
    stack=[]
    for i in range(n):
        stack.append(a[i])
    return stack

    # code here


#Function to print minimum value in stack each time while popping.    
def _getMinAtPop(stack):
    l=[]
    while stack:
        
        l1=min(stack)
        l.append(l1)
        stack.pop()
        print(l1, end=" ")
            
        return arr




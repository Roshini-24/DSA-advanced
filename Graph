class Solution:
    def printGraph(self, V : int, edges : List[List[int]]) -> List[List[int]]:
        mp = {}
        for i in range(V):
            mp[i] = []
        for i in edges:
            mp[i[0]].append(i[1])
            mp[i[1]].append(i[0])
        res = []
        for i in mp:
            res.append(mp[i])
        return res

from typing import List
from queue import Queue
from collections import deque
class Solution:
    #Function to return Breadth First Traversal of given graph.
    def bfsOfGraph(self, V: int, adj: List[List[int]]) -> List[int]:
        visited = [False]*len(adj)
        l=[]
        q= deque()
        q.append(0)
        visited[0] = True
    
        while q:
            s = q.popleft()
            l.append(s)
    
            for u in adj[s]:
                if visited[u] == False:
                    q.append(u)
                    visited[u] = True
        return l


import sys
sys.setrecursionlimit(10**8)
class Solution:
    def numIslands(self,grid):
        visited=[[0]*len(grid[0]) for i in range(len(grid))]
        
        #Function to check if the given coordinates are valid or not.
        def isValid(x,y):
            if (x>=0 and x<n) and (y>=0 and y<m):
                return True
            return False
        
        #Depth First Search to explore the connected components.
        def dfs(grid,x,y):
            visited[x][y]=1
            for i in [[-1,-1],[1,1],[1,0],[0,1],[1,-1],[-1,1],[-1,0],[0,-1]]:
                if isValid(x+i[0],y+i[1]) and visited[x+i[0]][y+i[1]]==0:
                    if grid[x+i[0]][y+i[1]]==1:
                        dfs(grid,x+i[0],y+i[1])
        
        count=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if visited[i][j]==0 and grid[i][j]==1:
                    dfs(grid,i,j)
                    count+=1
        return count




from collections import deque
class Solution:
    
    #Function to check if cell indexes are within bounds.
    def isValid(self, x, y, N):
        return (x >= 0 and x < N and y >= 0 and y < N)
    
    #Function to find out minimum steps Knight needs to reach target position.
    def minStepToReachTarget(self, KnightPos, TargetPos, N):
        dxy = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
        KnightPos[0]-=1
        KnightPos[1]-=1
        TargetPos[0]-=1
        TargetPos[1]-=1
        
        #using boolean list to mark visited cells and currently 
        #marking all the cells as false
        vis = [[False for i in range(N)] for j in range(N)]
        
        #queue for storing visited cells by knight in board and steps taken.
        q = deque()
        #pushing starting position of knight with 0 distance.
        q.append([KnightPos[0], KnightPos[1], 0])
        
        #marking starting cell as visited.
        vis[KnightPos[0]][KnightPos[1]] = True
        
        while(len(q)):
            
            #storing cell indexes and steps of front element and popping them.
            cur = q.popleft()
            x = cur[0]
            y = cur[1]
            steps = cur[2]
            
            #if we reach the required cell, we return true.
            if(x == TargetPos[0] and y == TargetPos[1]):
                return steps
                
            #using loop to reach all the cells that can be reached by knight.
            for i in range(8):
                
                n_x = x + dxy[i][0]
                n_y = y + dxy[i][1]
                
                #if cell indexes are valid and cell is not visited, we push the 
				#indexes in queue with steps and mark cell as visited.
                if(self.isValid(n_x, n_y, N) and vis[n_x][n_y] == False):
                    q.append([n_x, n_y, steps + 1])
                    vis[n_x][n_y] = True
        return -1



class Solution:
    #Function to find minimum time required to rot all oranges. 
    def orangesRotting(self, grid):
        from queue import Queue
        
        
        ct = 0 
        res = -1 
        
        #queue to store cells which have rotten oranges.
        q = Queue()
        dx = [-1,1,0,0]
        dy = [0,0,-1,1]
        
        #traversing over all the cells of the matrix.
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                
                #if grid value is more than 0, we increment the counter.
                if grid[i][j]>0:
                    ct+=1
                    
                #if grid value is 2, we push the cell indexes into queue.
                if(grid[i][j]==2):
                    q.put([i,j])
        
        while not q.empty():
            
            #incrementing result counter.
            res+=1 
            size = q.qsize()
            for k in range(size):
                
                #popping the front element of queue and storing cell indexes.
                cur = q.get()
                ct -= 1
                
                #traversing the adjacent vertices.
                for i in range(4):
                    x = cur[0] + dx[i]
                    y = cur[1] + dy[i]
                    
                    #if cell indexes are within matrix bounds and grid value
                    #is not 1, we continue the loop else we store 2 in current
                    #cell and push the cell indexes in the queue.
                    if x>=len(grid) or x<0 or y>=len(grid[0]) or y<0 or grid[x][y]!=1:
                        continue
                    grid[x][y] = 2
                    q.put([x,y])
        
        #returning the minimum time.
        if ct:
            return -1
        else:
            return max(0,res)



from collections import deque
class Solution:
    def isValid(self, x, y, n, m):
        return (x >= 0 and x < n and y >= 0 and y < m)
    def nearest(self, grid):
        dx = [-1,1,0,0]
        dy = [0,0,-1,1]
        n = len(grid)
        m = len(grid[0])
        dp = [[100000 for i in range(m)] for j in range(n)]
        q = deque()
        for i in range(n):
            for j in range(m):
                if(grid[i][j] == 1):
                    dp[i][j] = 0
                    q.append([i,j])
        while(len(q)):
            cur = q.popleft()
            x = cur[0]
            y = cur[1]
            for i in range(4):
                n_x = x + dx[i]
                n_y = y + dy[i]
                if(self.isValid(n_x, n_y, n, m) and dp[n_x][n_y] > dp[x][y] + 1):
                    dp[n_x][n_y] = dp[x][y] + 1
                    q.append([n_x, n_y])
        return dp




    #Function to return a list containing the DFS traversal of the graph.
    def dfsOfGraph(self, V, adj):
        visited = [False] * len(adj)
        l=[]
        #DFSRec(adj, s, visited)# code here
        def DFSRec(adj, s, visited):
            visited[s] = True
        
            l.append(s)
        
            for u in adj[s]:
        
                if visited[u] == False:
                    DFSRec(adj, u, visited)
        DFSRec(adj, 0, visited)
        return l




class Solution:
    
    def DFSUtil(self, adj, v, visited):
    
        #marking current vertex as visited.
        visited[v] = True
        
        #iterating over the adjacent vertices.
        for i in adj[v]:
            
            #if any vertex is not visited, we call dfs function recursively.
            if visited[i] == False:
                self.DFSUtil(adj, i, visited)
    
    
    #Function to find a Mother Vertex in the Graph.
    def findMotherVertex(self, V, adj):
    
        #boolean list to mark the visited nodes and initially all are
        #initialized as not visited.
        visited =[False]*V
        
        #variable to store last finished vertex (or mother vertex).
        v=0
        
        #iterating over all the vertices
        for i in range(V):
            
            #if current vertex is not visited, we call the dfs 
		    #function and then update the variable v.
            if visited[i]==False:
                self.DFSUtil(adj,i,visited)
                v = i
        
        
        #we reset all the vertices as not visited.
        visited = [False]*V
        
        #calling the dfs function to do DFS beginning from v to check
        #if all vertices are reachable from it or not.
        self.DFSUtil(adj, v, visited)
        
        #iterating on boolean list and returning -1 if any vertex is
		#not visited else the mother vertex.
        if any(i == False for i in visited):
            return -1
        else:
            return v



class Solution:
    def levelOfX(self, V, adj, X):
        
        visited = [False]*V
        q = deque()
        q.append(0)
        visited[0] = True
        level = 0
        while q:
            for _ in range(len(q)):
                u = q.popleft()
                if u == X:
                    return level
                for v in adj[u]:
                    if visited[v] == False:
                        q.append(v)
                        visited[v] = True
            level+=1
        return -1



  
    #Function to check whether the cell is within the matrix bounds.
    def isValid(self, x, y, n, m):
        return (x >= 0 and x < n and y >= 0 and y < m)
        
    #Function to find the number of 'X' total shapes.
    def xShape(self, grid):
        
        n = len(grid)
        m = len(grid[0])
        dx = [-1,1,0,0]
        dy = [0,0,-1,1]
        q = deque()
        ans = 0
        
        #traversing all the cells of the matrix.
        for i in range(n):
            for j in range(m):
                
                #if grid value is X, we increment the counter, update grid
                #value as 0 and push cell index in queue.
                if(grid[i][j] == 'X'):
                    ans = ans + 1
                    grid[i][j] = 'O'
                    q.append([i,j])
                    
                    
                    while(len(q)):
                        cur = q.popleft()
                        x = cur[0]
                        y = cur[1]
                        
                        #traversing all the adjacent cells.
                        for k in range(4):
                            n_x = x + dx[k]
                            n_y = y + dy[k]
                            
                            #if grid value is X and cell is within bounds, we 
                            #update grid value as 0 and push cell index in queue.
                            if(self.isValid(n_x,n_y,n,m) and grid[n_x][n_y]=='X'):
                                grid[n_x][n_y] = 'O'
                                q.append([n_x, n_y])
                                
        #returning the count.
        return ans




#Function to detect cycle in an undirected graph.
    def isCycle(self, V: int, adj: List[List[int]]) -> bool:
        visited= [False]* len(adj)
        
        def DFSRec(adj,s,visited,parent):
            visited[s]= True
            
            for u in adj[s]:
                if visited[u]==False:
                    if DFSRec(adj,u,visited,s):
                        return True 
                elif u!=parent:
                    return True 
            
            return False
    
        for i in range(len(adj)):
            
            if(visited[i]==False):
                
                if DFSRec(adj,i,visited,-1):
                    return True
        
        return False




 #Function to detect cycle in a directed graph.
    def isCyclic(self, V, adj):
        visited= [False]* len(adj)
        recSt= [False]* len(adj)
        
        def DFSRec(adj,s,visited,recSt):
            visited[s]= True
            recSt[s] = True
            
            for u in adj[s]:
                if visited[u]==False:
                    if DFSRec(adj,u,visited,recSt):
                        return True 
                        
                elif recSt[u]==True:
                    return True 
                    
            recSt[s]= False
            return False
        
        
        
        for i in range(len(adj)):
            
            if(visited[i]==False):
                
                if DFSRec(adj,i,visited,recSt):
                    return True
        
        return False





    #Function to return list containing vertices in Topological order.
    def topoSort(self, V, adj):
        indegree = {}
        res = []
        for i in range(V):
            indegree[i]=0
        for i in range(V):
            for j in adj[i]:
                indegree[j]+=1
        q = []
        for i in indegree:
            if indegree[i]==0:
                q.append(i)
        
        while q:
            l=q.pop(0)
            res.append(l)
            for i in adj[l]:
                indegree[i]-=1
                if indegree[i]==0:
                    q.append(i)
        return res

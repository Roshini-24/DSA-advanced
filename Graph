class Solution:
    def printGraph(self, V : int, edges : List[List[int]]) -> List[List[int]]:
        mp = {}
        for i in range(V):
            mp[i] = []
        for i in edges:
            mp[i[0]].append(i[1])
            mp[i[1]].append(i[0])
        res = []
        for i in mp:
            res.append(mp[i])
        return res

from typing import List
from queue import Queue
from collections import deque
class Solution:
    #Function to return Breadth First Traversal of given graph.
    def bfsOfGraph(self, V: int, adj: List[List[int]]) -> List[int]:
        visited = [False]*len(adj)
        l=[]
        q= deque()
        q.append(0)
        visited[0] = True
    
        while q:
            s = q.popleft()
            l.append(s)
    
            for u in adj[s]:
                if visited[u] == False:
                    q.append(u)
                    visited[u] = True
        return l


import sys
sys.setrecursionlimit(10**8)
class Solution:
    def numIslands(self,grid):
        visited=[[0]*len(grid[0]) for i in range(len(grid))]
        
        #Function to check if the given coordinates are valid or not.
        def isValid(x,y):
            if (x>=0 and x<n) and (y>=0 and y<m):
                return True
            return False
        
        #Depth First Search to explore the connected components.
        def dfs(grid,x,y):
            visited[x][y]=1
            for i in [[-1,-1],[1,1],[1,0],[0,1],[1,-1],[-1,1],[-1,0],[0,-1]]:
                if isValid(x+i[0],y+i[1]) and visited[x+i[0]][y+i[1]]==0:
                    if grid[x+i[0]][y+i[1]]==1:
                        dfs(grid,x+i[0],y+i[1])
        
        count=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if visited[i][j]==0 and grid[i][j]==1:
                    dfs(grid,i,j)
                    count+=1
        return count




from collections import deque
class Solution:
    
    #Function to check if cell indexes are within bounds.
    def isValid(self, x, y, N):
        return (x >= 0 and x < N and y >= 0 and y < N)
    
    #Function to find out minimum steps Knight needs to reach target position.
    def minStepToReachTarget(self, KnightPos, TargetPos, N):
        dxy = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
        KnightPos[0]-=1
        KnightPos[1]-=1
        TargetPos[0]-=1
        TargetPos[1]-=1
        
        #using boolean list to mark visited cells and currently 
        #marking all the cells as false
        vis = [[False for i in range(N)] for j in range(N)]
        
        #queue for storing visited cells by knight in board and steps taken.
        q = deque()
        #pushing starting position of knight with 0 distance.
        q.append([KnightPos[0], KnightPos[1], 0])
        
        #marking starting cell as visited.
        vis[KnightPos[0]][KnightPos[1]] = True
        
        while(len(q)):
            
            #storing cell indexes and steps of front element and popping them.
            cur = q.popleft()
            x = cur[0]
            y = cur[1]
            steps = cur[2]
            
            #if we reach the required cell, we return true.
            if(x == TargetPos[0] and y == TargetPos[1]):
                return steps
                
            #using loop to reach all the cells that can be reached by knight.
            for i in range(8):
                
                n_x = x + dxy[i][0]
                n_y = y + dxy[i][1]
                
                #if cell indexes are valid and cell is not visited, we push the 
				#indexes in queue with steps and mark cell as visited.
                if(self.isValid(n_x, n_y, N) and vis[n_x][n_y] == False):
                    q.append([n_x, n_y, steps + 1])
                    vis[n_x][n_y] = True
        return -1





